{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' ).isPrimitive;\nvar isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving unbiased sample variance.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute an unbiased sample variance.\n*\n* -   The difference between the unbiased sample variance in a window \\\\(W_i\\\\) and the unbiased sample variance in a window \\\\(W_{i+1})\\\\) is given by\n*\n*     ```tex\n*     \\Delta s^2 = s_{i+1}^2 - s_{i}^2\n*     ```\n*\n* -   If we multiply both sides by \\\\(N-1\\\\),\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = (N-1)s_{i+1}^2 - (N-1)s_{i}^2\n*     ```\n*\n* -   If we substitute the definition of the unbiased sample variance having the form\n*\n*     ```tex\n*     \\begin{align*}\n*     s^2 &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i^2 - 2\\bar{x}x_i + \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2\\bar{x} \\sum_{i=1}^{N} x_i + \\sum_{i=1}^{N} \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - \\frac{2N\\bar{x}\\sum_{i=1}^{N} x_i}{N} + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2N\\bar{x}^2 + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - N\\bar{x}^2 \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     we return\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = \\biggl(\\sum_{k=1}^N x_k^2 - N\\bar{x}_{i+1}^2 \\biggr) - \\biggl(\\sum_{k=0}^{N-1} x_k^2 - N\\bar{x}_{i}^2 \\biggr)\n*     ```\n*\n* -   This can be further simplified by recognizing that subtracting the sums reduces to \\\\(x_N^2 - x_0^2\\\\); in which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= x_N^2 - x_0^2 - N\\bar{x}_{i+1}^2 + N\\bar{x}_{i}^2 \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1}^2 - \\bar{x}_{i}^2) \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1} - \\bar{x}_{i})(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* -   Recognizing that the difference of means can be expressed\n*\n*     ```tex\n*     \\bar{x}_{i+1} - \\bar{x}_i = \\frac{1}{N} \\biggl( \\sum_{k=1}^N x_k - \\sum_{k=0}^{N-1} x_k \\biggr) = \\frac{x_N - x_0}{N}\n*     ```\n*\n*     and substituting into the equation above\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = x_N^2 - x_0^2 - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     ```\n*\n* -   Rearranging terms gives us the update equation\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= (x_N - x_0)(x_N + x_0) - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     &= (x_N - x_0)(x_N + x_0 - \\bar{x}_{i+1} - \\bar{x}_{i}) \\\\\n*     &= (x_N - x_0)(x_N - \\bar{x}_{i+1} + x_0 - \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [mean] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmvariance( 3 );\n*\n* var s2 = accumulator();\n* // returns null\n*\n* s2 = accumulator( 2.0 );\n* // returns 0.0\n*\n* s2 = accumulator( -5.0 );\n* // returns 24.5\n*\n* s2 = accumulator( 3.0 );\n* // returns 19.0\n*\n* s2 = accumulator( 5.0 );\n* // returns 28.0\n*\n* s2 = accumulator();\n* // returns 28.0\n*\n* @example\n* var accumulator = incrmvariance( 3, -2.0 );\n*/\nfunction incrmvariance( W, mean ) {\n\tvar delta;\n\tvar buf;\n\tvar tmp;\n\tvar M2;\n\tvar mu;\n\tvar d1;\n\tvar d2;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a positive integer. Value: `%s`.', W ) );\n\t}\n\tbuf = new Array( W );\n\tn = W - 1;\n\tM2 = 0.0;\n\ti = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( mean ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide a number. Value: `%s`.', mean ) );\n\t\t}\n\t\tmu = mean;\n\t\treturn accumulator2;\n\t}\n\tmu = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample variance. If not provided a value, the accumulator function returns the current unbiased sample variance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} unbiased sample variance or null\n\t*/\n\tfunction accumulator1( x ) {\n\t\tvar k;\n\t\tvar v;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn ( isnan( M2 ) ) ? NaN : 0.0;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn M2 / (N-1);\n\t\t\t}\n\t\t\treturn M2 / n;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tmu += delta / N;\n\t\t\tM2 += delta * (x - mu);\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn M2 / (N-1);\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\tM2 = 0.0;\n\t\t\treturn M2;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tN = 1;\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tv = buf[ k ];\n\t\t\t\t\tif ( isnan( v ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdelta = v - mu;\n\t\t\t\t\tmu += delta / N;\n\t\t\t\t\tM2 += delta * (v - mu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tdelta = x - tmp;\n\t\t\td1 = tmp - mu;\n\t\t\tmu += delta / W;\n\t\t\td2 = x - mu;\n\t\t\tM2 += delta * (d1 + d2);\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\n\t\tbuf[ i ] = x;\n\t\treturn M2 / n;\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample variance. If not provided a value, the accumulator function returns the current unbiased sample variance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} unbiased sample variance or null\n\t*/\n\tfunction accumulator2( x ) {\n\t\tvar k;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn M2 / N;\n\t\t\t}\n\t\t\treturn M2 / W;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tM2 += delta * delta;\n\t\t\treturn M2 / N;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tif ( isnan( buf[ k ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tdelta = buf[ k ] - mu;\n\t\t\t\t\tM2 += delta * delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tM2 += ( x-tmp ) * ( x-mu + tmp-mu );\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\n\t\tbuf[ i ] = x;\n\t\treturn M2 / W;\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = incrmvariance;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a moving unbiased sample variance incrementally.\n*\n* @module @stdlib/stats-incr-mvariance\n*\n* @example\n* var incrmvariance = require( '@stdlib/stats-incr-mvariance' );\n*\n* var accumulator = incrmvariance( 3 );\n*\n* var s2 = accumulator();\n* // returns null\n*\n* s2 = accumulator( 2.0 );\n* // returns 0.0\n*\n* s2 = accumulator( -5.0 );\n* // returns 24.5\n*\n* s2 = accumulator( 3.0 );\n* // returns 19.0\n*\n* s2 = accumulator( 5.0 );\n* // returns 28.0\n*\n* s2 = accumulator();\n* // returns 28.0\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isPositiveInteger", "isNumber", "isnan", "format", "incrmvariance", "W", "mean", "delta", "buf", "tmp", "M2", "mu", "d1", "d2", "N", "n", "i", "accumulator2", "accumulator1", "x", "k", "v", "main"]
}
